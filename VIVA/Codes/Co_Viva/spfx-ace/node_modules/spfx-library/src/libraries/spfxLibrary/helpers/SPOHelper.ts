import { SPFI, SPFx, spfi } from "@pnp/sp";
import "@pnp/sp/webs";
import "@pnp/sp/profiles";
import "@pnp/sp/lists";
import "@pnp/sp/items";
import "@pnp/sp/site-users/web";
import { SPHttpClient } from "@microsoft/sp-http";
import { LoggerHelper } from "./LoggerHelper";
import { Constants } from "./Constants";
import { APIInvoker } from "./APIInvoker";
import { IList } from "@pnp/sp/lists";
import { CacheHelper } from "./CacheHelper";
/**
 * SPOHelper.
 */
export class SPOHelper {
  private loggerHelper: LoggerHelper;
  private cacheHelper: CacheHelper;
  private wpcontext: any;
  private sp: SPFI;
  public constructor(context: any, configuration: any) {
    this.loggerHelper = configuration.logger;
    this.wpcontext = context;
    this.sp = spfi().using(SPFx(this.wpcontext));
    this.cacheHelper = new CacheHelper();
  }

  /**
   * getListByTitle
    @param listTitle:string  
  */
  public async getListByTitle(listTitle: string): Promise<IList> {
    try {
      const list = this.sp.web.lists.getByTitle(listTitle);
      return Promise.resolve(list)

    } catch (error) {
      this.loggerHelper.trackException(error);
    }
  }

  /**
  * Method to fetch all active items from the list.
  * @param list list id.
  * @param orderBy orderBy column.
  */
  public async getAllActiveItems(
    list: string,
    orderBy: string,
    filter: string = ""
  ): Promise<any[]> {
    let items: any[] = [];
    var currDateTime = new Date();
    try {
      items = await this.sp.web.lists
        .getById(list)
        .items.filter(
          `((${Constants.NotificationControl.IsActive} eq 1) and 
          (((${Constants.NotificationControl.StartDate
          } le '${currDateTime.toISOString()}') and 
          (${Constants.NotificationControl.EndDate
          } ge '${currDateTime.toISOString()}')) or
           ((${Constants.NotificationControl.StartDate
          } le '${currDateTime.toISOString()}') and 
           (${Constants.NotificationControl.EndDate} eq null)) or ((${Constants.NotificationControl.StartDate
          } eq null) and 
           (${Constants.NotificationControl.EndDate
          } ge '${currDateTime.toISOString()}')) or
           ((${Constants.NotificationControl.EndDate} eq null) and (${Constants.NotificationControl.StartDate
          } eq null))))`
        )
        .orderBy(orderBy)();
    } catch (error) {
      this.loggerHelper.trackException(error);

    }
    return items;
  }

  /**
    * Method to fetch all items from the list based on select,filter and orderby query.
    * @param listTitle  list Title.
    * @param selectFields select Fields
    * @param orderByColumnName  orderByColumnName Query
    * @param ascending  whether to sort orderByColumnName by ascending or descending
    * @param filterQuery  filter Query
    */
  public async getAllListItemsUsingSelectFilterOrderBy(
    listTitle: string,
    selectFields: string,
    orderByColumnName: string,
    ascending: boolean,
    filterQuery: string = ""
  ): Promise<any[]> {
    let items: any[] = [];
    try {
      this.loggerHelper.trackTrace(
        "Getting all items from the list : " + listTitle
      );
      items = await this.sp.web.lists
        .getByTitle(listTitle)
        .select(selectFields).items.filter(filterQuery)
        .orderBy(orderByColumnName, ascending).top(500)();

    } catch (error) {
      this.loggerHelper.trackException(error);

    }
    return items;
  }

  /**
  * Method to fetch M365 group Ids.
  * @param userids  user ids.
  */

  public async getM365GroupIdsFromSPOIds(userids: number[]): Promise<string[]> {
    let items: any[] = [];
    try {
      for (let item of userids) {
        let m365User = await this.sp.web.getUserById(item)();
        items.push(m365User.LoginName.split("|")[2]);
      }
    } catch (error) {
      this.loggerHelper.trackException(error);
    }

    return items;
  }

  /**
  * Method to fetch items from list.
  * @param spContext  sp Context.
  * @param listId  list Id.
  * @param selectFields  Fields to select.
  */
  public fetchListItems = async (
    spContext: any,
    listId: string,
    selectFields: string
  ): Promise<any> => {
    if (!listId) {
      return Promise.reject("No listId specified.");
    }

    const response = await (
      await spContext.spHttpClient.get(
        `${spContext.pageContext.web.absoluteUrl}/_api/web/lists/GetById(id='${listId}')/items?$select=` +
        selectFields,
        SPHttpClient.configurations.v1
      )
    ).json();

    return Promise.resolve(response);
  };

  /**
   * Fetch ListItems By Title.
   * @param spContext 
   * @param listTitle 
   * @param selectFields 
   * @returns 
   */
  public fetchListItemsByTitle = async (
    spContext: any,
    listTitle: string,
    selectFields: string
  ): Promise<any> => {
    if (!listTitle) {
      return Promise.reject("No list specified.");
    }

    const response = await (
      await spContext.spHttpClient.get(
        `${spContext.pageContext.web.absoluteUrl}/_api/web/lists/getByTitle('${listTitle}')/items?$select=` +
        selectFields,
        SPHttpClient.configurations.v1
      )
    ).json();

    return Promise.resolve(response);
  }

  /**
   * Get Events From EventList
   * @param spContext 
   * @param listTitle 
   * @returns 
   */
  public GetEventsFromEventList = async (
    spContext: any,
    listTitle: string
  ): Promise<any> => {
    if (!listTitle) {
      return Promise.reject("No list specified.");
    }

    //var today = new Date();
    let url: string = `${spContext.pageContext.web.absoluteUrl}/_api/web/lists/getByTitle('${listTitle}')/items`;

    url = url + `?$filter=EndDate ge datetime'` + new Date().toISOString() + `'&$orderby=EventDate asc`;

    const response = await (
      await spContext.spHttpClient.get(
        url,
        SPHttpClient.configurations.v1
      )
    ).json();

    return Promise.resolve(response);
  };

  /**
  * Method to get groups for logged in User.
  */

  public async getMyGroups(): Promise<any[]> {
    let groups = await this.sp.web.currentUser.groups();
    return groups;
  }

  /**
* Method to get And Updatet User Compliance Data in UserProfile.
* @param configuration  configuration.
* @param spContext  spContext.
* @param userLoginname  userLoginname.
*/

  public getAndUpdatetUserComplianceDataInUserProfile = async (
    configuration: any,
    spContext: any,
    userLoginname: string
  ): Promise<any> => {
    let isValid: boolean = false;
    try {
      let responseUserProfile = await this.getUserProfilePropertyValue(
        spContext,
        Constants.UserProfileProperty,
        userLoginname
      );
      if (Constants.IsNullOrUndefinedOrEmpty(responseUserProfile)) {
        let apiValue: any = await this.InvokeComplianceAPI(
          configuration,
          spContext,
          userLoginname
        );
        return Promise.resolve(apiValue);
      } else if (
        (!Constants.IsNullOrUndefinedOrEmpty(responseUserProfile)) &&
        responseUserProfile?.split("|")[1] == this.getCurrentUTCDate()
      ) {
        isValid = true;
        return Promise.resolve(isValid);
      } else {
        let apiValue: any = await this.InvokeComplianceAPI(
          configuration,
          spContext,
          userLoginname
        );
        return Promise.resolve(apiValue);
      }
    } catch (error) {
      isValid = true;

      this.loggerHelper.trackException(error, {
        message:
          "Error occured in getAndUpdatetUserComplianceDataInUserProfile",
      });
      return Promise.resolve(isValid);
    }
  };

  /**
* Method to Invoke Compliance API.
* @param configuration  configuration.
* @param spContext  spContext.
* @param userLoginname  userLoginname.
* @returns any.
*/
  public InvokeComplianceAPI = async (
    configuration: any,
    spContext: any,
    userLoginname: string
  ): Promise<any> => {
    let isValid: boolean = false;

      return await this.getUserComplianceData(configuration,spContext,userLoginname).then(
        async (responseUserCompliance: any): Promise<boolean> => {
          if (responseUserCompliance === Constants.GuidForCompliantUser) {
            isValid = true;
            var propertyValue =
              responseUserCompliance + "|" + this.getCurrentUTCDate();

            if (!Constants.IsNullOrUndefinedOrEmpty(configuration.UpdateTrue)) {
              await this.updateUserProfilePropertyValue(
                spContext,
                Constants.UserProfileProperty,
                propertyValue,
                userLoginname
              );
            }
            return Promise.resolve(isValid);
          }
          else if (responseUserCompliance === "true") {
            isValid = true;
            return Promise.resolve(isValid);
          }
          else {
            isValid = false;
            return Promise.resolve(isValid);
          }
        }
      );
    
  };

  /**
* Method to get User Compliance Data.
* @param configuration  configuration.
* @returns any.
*/

  public getUserComplianceData = async (configuration: any,spContext?:any, userLoginname?:any): Promise<any> => {
    let isCompliant = this.cacheHelper.getLocalStorage(Constants.ComplianceAPI_CacheKey);
    if (Constants.IsNullOrUndefinedOrEmpty(isCompliant)) {
      let isValid: string = "true";
      var requestPayloadForMainResults = {
        apiURL: configuration.apiURL,
        APImethod: configuration.APImethod,
        OcpApimSubscriptionKey: configuration.OcpApimSubscriptionKey,
        OcpApimTrace: configuration.OcpApimTrace,
        RequestObject: configuration.RequestObject,
        APITimeoutLimit: configuration.APITimeoutLimit,
        Scope: configuration.Scope,
        context:configuration.context
      };
      let userProfileFlag = this.cacheHelper.getLocalStorage(Constants.IsCompliantFlag_CacheKey);
      if (userProfileFlag === "true") {
        setTimeout((): void => {
          this.getUserComplianceData(configuration,spContext,userLoginname).then((v: any) => { return Promise.resolve(v) });
        }, 50);
      }
      else {
        this.cacheHelper.setLocalStorage(Constants.IsCompliantFlag_CacheKey, "true", Constants.Compliance_ExpirationTime_CacheKey);
        return await new APIInvoker(configuration)
          .callAPI(requestPayloadForMainResults)
          .then((response: any): any => {

            if (response && response?.payload && response?.payload?.isViVaUser) {
              isValid = response.payload.isViVaUser;
            }
            this.cacheHelper.setLocalStorage(Constants.ComplianceAPI_CacheKey, isValid, Constants.Compliance_ExpirationTime_CacheKey);
            this.cacheHelper.setLocalStorage(Constants.IsCompliantFlag_CacheKey, "false", Constants.Compliance_ExpirationTime_CacheKey);
            return Promise.resolve(isValid);
          })
          .catch((ex: any) => {
            this.cacheHelper.setLocalStorage(Constants.ComplianceAPI_CacheKey, isValid, Constants.Compliance_ExpirationTime_CacheKey);
            this.cacheHelper.setLocalStorage(Constants.IsCompliantFlag_CacheKey, "false", Constants.Compliance_ExpirationTime_CacheKey);
            this.loggerHelper.trackException(ex, {
              message: "Error occured in getAPIResults"
            });
            return Promise.resolve(isValid);
          });
      }
    }
    else if(isCompliant === Constants.GuidForCompliantUser && !Constants.IsNullOrUndefinedOrEmpty(configuration.UpdateTrue)){
      var propertyValue =
              isCompliant + "|" + this.getCurrentUTCDate();
        await this.updateUserProfilePropertyValue(
          spContext,
          Constants.UserProfileProperty,
          propertyValue,
          userLoginname
        );
      
      return Promise.resolve(isCompliant);
    }
    else {
      return Promise.resolve(isCompliant);
    }
  };

  /**
  * Method to get User Profile Property Value.
  * @param spContext  sp Context.
  * @param propertyName  propertyName.
  * @param selectFields  Fields to select.
  * @returns any
  */

  public getUserProfilePropertyValue = async (
    spContext: any,
    propertyName: string,
    userLoginname: string
  ): Promise<any> => {
        if (!propertyName) {
          return Promise.reject("No propertyName specified.");
        }
        try {
          const profile = await this.sp.profiles.myProperties();
          const myAppsPropValue = profile.UserProfileProperties.filter((obj: any) => {
            return obj.Key == propertyName;
          })[0]?.Value;
          return Promise.resolve(myAppsPropValue);
        }
        catch (error) {
          this.loggerHelper.trackException(error, {
            message: "Error occured in getUserProfilePropertyValue"
          });
          return Promise.resolve(null);
        }
  };


  /**
   * Get Property Value From SPO User Profile
   * @param propertyName 
   * @returns 
   */
  public getPropertyValueFromSPOUserProfile = async (
    propertyName: string,
  ): Promise<any> => {
    if (!propertyName) {
      return Promise.reject("No propertyName specified.");
    }
    const profile = await this.sp.profiles.myProperties();
    const myAppsPropValue = profile.UserProfileProperties.filter((obj: any) => {
      return obj.Key == propertyName;
    })[0]?.Value;
    return Promise.resolve(myAppsPropValue);
  };


  /**
   * Method to get User Profile Property Value Array.
   * @param propertyName  propertyName.
   * @returns any
   */
  public async getUserProfilePropertyValueArray(propertyName: string): Promise<any> {
    try {
      const profile = await this.sp.profiles.myProperties();
      const myAppsPropValue = profile.UserProfileProperties.filter((obj: any) => {
        return obj.Key == propertyName;
      })[0]?.Value;
      if (Constants.IsNullOrUndefinedOrEmpty(myAppsPropValue)) {
        return "";
      }
      else if (myAppsPropValue.length > 0) {
        return JSON.parse(myAppsPropValue);
      }
      else
        return [];
    }
    catch (Exception) {
      console.log(Exception);
      return "";
    }
  }

  /**
   * Update user profile property value of spohelper
    * @param spContext  sp Context.
    * @param propertyName  property Name.
    * @param propertyValue  property Value.
    * @param userLoginname  user Login name.
    * @returns any
   */
  public updateUserProfilePropertyValue = async (
    spContext: any,
    propertyName: string,
    propertyValue: string,
    userLoginname: string
  ): Promise<any> => {
    try {
      if (!propertyName) {
        return Promise.reject("No propertyName specified.");
      }
      let userData = {
        accountName: "i:0#.f|membership|" + userLoginname,
        propertyName: propertyName, //can also be used to set custom single value profile properties
        propertyValue: propertyValue
      };
      let spOpts = {
        headers: {
          Accept: "application/json;odata=nometadata",
          "Content-type": "application/json;odata=verbose",
          "odata-version": ""
        },
        body: JSON.stringify(userData)
      };
      const response = await (
        await spContext.spHttpClient.post(
          `${spContext.pageContext.web.absoluteUrl}/_api/SP.UserProfiles.PeopleManager/SetSingleValueProfileProperty`,
          SPHttpClient.configurations.v1,
          spOpts
        )
      ).json();

      Promise.resolve(response);
    } catch (error) {
    }
  };

  /**
     * Update user profile property value of spohelper
      * @param checkedItems  array of checked items.
      * @param propertyName  property Name.
      * @returns any
     */
  public async setMyProfilePropsArray(checkedItems: any[], propertyName: string): Promise<any> {
    try {
      const profile = await this.sp.profiles.myProperties();
      const response = await this.sp.profiles.setSingleValueProfileProperty(profile.AccountName, propertyName, JSON.stringify(checkedItems));
      return Promise.resolve(response);
    }
    catch (Exception) {
      console.log(Exception);
    }

  }



  /**
   * Gets current utcdate
   * @returns current utcdate 
   */
  public getCurrentUTCDate(): string {
    let currentUTCDate: string;
    var today = new Date();
    currentUTCDate =
      today.getUTCFullYear() +
      "-" +
      (today.getUTCMonth() + 1) +
      "-" +
      today.getUTCDate();
    return currentUTCDate;
  }

  /**
   * Reads configuration from list
   * @returns configuration from list
   */
  public async ReadConfigurationFromList(context: any): Promise<any> {
    let configuration = {
      TenantId: "",
      ClientId: "",
      AADRedirectUrl: "",
      Scope: "",
      OcpApimSubscriptionKey: "",
      OcpApimTrace: "",
      ComplianceAPIURL: "",
      APImethod: "",
      APITimeoutLimit: "",
      PageToSkip: "",
      RedirectURL: "",
      IsAllowed: false
    };
    try {
      if (Constants.SPOListForConfiguration) {
        const selectFields: string = Constants.selectFieldsFromList;
        let listItems = await this.fetchListItemsByTitle(
          context,
          Constants.SPOListForConfiguration,
          selectFields
        );

        if (listItems && listItems.value && listItems.value.length > 0) {
          listItems.value.forEach((element: any) => {
            //By pass compliance check
            if (element.Title === Constants.AllowedLoginsColumn) {
              const allowedLoginsVal: string = element.HCLTechConfigValue;
              if (allowedLoginsVal) {
                const allowedLoginsArr: string[] = allowedLoginsVal.split(";");
                configuration.IsAllowed = allowedLoginsArr.some(
                  (e) =>
                    e.toLowerCase().trim() ===
                    context.pageContext.user.loginName.toLowerCase()
                );
              }
            }
            //Other configurations
            if (
              element.Title &&
              element.Title.toLowerCase().trim() ===
              Constants.TenantId.toLowerCase()
            ) {
              configuration.TenantId = element.HCLTechConfigValue;
            }
            if (
              element.Title &&
              element.Title.trim().toLowerCase() ===
              Constants.ClientId.toLowerCase()
            ) {
              configuration.ClientId = element.HCLTechConfigValue;
            }
            if (
              element.Title &&
              element.Title.trim().toLowerCase() ===
              Constants.AADRedirectUrl.toLowerCase()
            ) {
              configuration.AADRedirectUrl = element.HCLTechConfigValue;
            }
            if (
              element.Title &&
              element.Title.trim().toLowerCase() ===
              Constants.Scope.toLowerCase()
            ) {
              configuration.Scope = element.HCLTechConfigValue;
            }
            if (
              element.Title &&
              element.Title.trim().toLowerCase() ===
              Constants.OcpApimSubscriptionKey.toLowerCase()
            ) {
              configuration.OcpApimSubscriptionKey = element.HCLTechConfigValue;
            }
            if (
              element.Title &&
              element.Title.trim().toLowerCase() ===
              Constants.OcpApimTrace.toLowerCase()
            ) {
              configuration.OcpApimTrace = element.HCLTechConfigValue;
            }
            if (
              element.Title &&
              element.Title.trim().toLowerCase() ===
              Constants.ComplianceAPIURL.toLowerCase()
            ) {
              configuration.ComplianceAPIURL = element.HCLTechConfigValue;
            }
            if (
              element.Title &&
              element.Title.trim().toLowerCase() ===
              Constants.APImethod.toLowerCase()
            ) {
              configuration.APImethod = element.HCLTechConfigValue;
            }
            if (
              element.Title &&
              element.Title.trim().toLowerCase() ===
              Constants.APITimeoutLimit.toLowerCase()
            ) {
              configuration.APITimeoutLimit = element.HCLTechConfigValue;
            }
            if (
              element.Title &&
              element.Title.trim().toLowerCase() ===
              Constants.PageToSkip.toLowerCase()
            ) {
              configuration.PageToSkip = element.HCLTechConfigValue;
            }
            if (
              element.Title &&
              element.Title.trim().toLowerCase() ===
              Constants.RedirectURL.toLowerCase()
            ) {
              configuration.RedirectURL = element.HCLTechConfigValue;
            }
          });
        }
      }
    } catch (error) {
      this.loggerHelper.trackException(error, {
        message: "Error occured in ReadConfigurationFromList"
      });
    }
    return Promise.resolve(configuration);
  }
}
