import "@pnp/sp/webs";
import "@pnp/sp/lists";
import "@pnp/sp/items";
import "@pnp/sp/site-users/web";
import { SPHttpClient } from "@microsoft/sp-http";
import { LoggerHelper } from "./LoggerHelper";
import { Constants } from "./Constants";
import { SPOHelper } from "./SPOHelper";

/**
 * Configuration helper
 */
export class ConfigurationHelper {
  private loggerHelper: LoggerHelper;
  private _context: any;
  private spHelper: SPOHelper;

  public constructor(context: any, configuration: any) {
    this.loggerHelper = configuration.logger;
    this._context = context;
  }

  /**
   * Fetch list items of configuration helper
   */
  public fetchListItems = async (
    spContext: any,
    listId: string,
    selectFields: string
  ): Promise<any> => {
    if (!listId) {
      return Promise.reject("No listId specified.");
    }

    const response = await (
      await spContext.spHttpClient.get(
        `${spContext.pageContext.web.absoluteUrl}/_api/web/lists/GetById(id='${listId}')/items?$select=` +
        selectFields,
        SPHttpClient.configurations.v1
      )
    ).json();

    return Promise.resolve(response);
  };

  /**
   * Reads configuration from list
   * @returns configuration from list
   */
  public async ReadConfigurationFromList(): Promise<any> {
    let configuration = {
      TenantId: "",
      ClientId: "",
      AADRedirectUrl: "",
      Scope: "",
      OcpApimSubscriptionKey: "",
      OcpApimTrace: "",
      ComplianceAPIURL: "",
      APImethod: "",
      APITimeoutLimit: "",
      PageToSkip: "",
      RedirectURL: "",
      CacheStorageExpiry:"",
      IsAllowed: false
    };
    try {

      if (Constants.SPOListForConfiguration) {
        const selectFields: string = Constants.selectFieldsFromList;
        let listItems = await this.fetchListItemsByTitle(
          this._context,
          Constants.SPOListForConfiguration,
          selectFields
        );

        if (listItems && listItems?.value && listItems?.value?.length > 0) {
          listItems.value.forEach((element: any) => {
            //Other configurations
            if (
              element.Title &&
              element.Title.toLowerCase().trim() ===
              Constants.TenantId.toLowerCase()
            ) {
              configuration.TenantId = element.HCLTechConfigValue;
              return;
            }
            if (
              element.Title &&
              element.Title.trim().toLowerCase() ===
              Constants.ClientId.toLowerCase()
            ) {
              configuration.ClientId = element.HCLTechConfigValue;
              return;
            }
            if (
              element.Title &&
              element.Title.trim().toLowerCase() ===
              Constants.AADRedirectUrl.toLowerCase()
            ) {
              configuration.AADRedirectUrl = element.HCLTechConfigValue;
              return;
            }
            if (
              element.Title &&
              element.Title.trim().toLowerCase() ===
              Constants.Scope.toLowerCase()
            ) {
              configuration.Scope = element.HCLTechConfigValue;
              return;
            }
            if (
              element.Title &&
              element.Title.trim().toLowerCase() ===
              Constants.OcpApimSubscriptionKey.toLowerCase()
            ) {
              configuration.OcpApimSubscriptionKey = element.HCLTechConfigValue;
              return;
            }
            if (
              element.Title &&
              element.Title.trim().toLowerCase() ===
              Constants.OcpApimTrace.toLowerCase()
            ) {
              configuration.OcpApimTrace = element.HCLTechConfigValue;
              return;
            }
            if (
              element.Title &&
              element.Title.trim().toLowerCase() ===
              Constants.ComplianceAPIURL.toLowerCase()
            ) {
              configuration.ComplianceAPIURL = element.HCLTechConfigValue;
              return;
            }
            if (
              element.Title &&
              element.Title.trim().toLowerCase() ===
              Constants.APImethod.toLowerCase()
            ) {
              configuration.APImethod = element.HCLTechConfigValue;
              return;
            }
            if (
              element.Title &&
              element.Title.trim().toLowerCase() ===
              Constants.APITimeoutLimit.toLowerCase()
            ) {
              configuration.APITimeoutLimit = element.HCLTechConfigValue;
              return;
            }
            if (
              element.Title &&
              element.Title.trim().toLowerCase() ===
              Constants.PageToSkip.toLowerCase()
            ) {
              configuration.PageToSkip = element.HCLTechConfigValue;
              return;
            }
            if (
              element.Title &&
              element.Title.trim().toLowerCase() ===
              Constants.RedirectURL.toLowerCase()
            ) {
              configuration.RedirectURL = element.HCLTechConfigValue;
              return;
            }
            if (
              element.Title && element.Title.trim().toLowerCase() === Constants.CacheStorageExpiry.toLowerCase()
            ) {
              configuration.CacheStorageExpiry = element.HCLTechConfigValue;
            }
          });
        }
      }
    } catch (error) {
      this.loggerHelper.trackException(error, {
        message: "Error occured in ReadConfigurationFromList"
      });
    }
    return Promise.resolve(configuration);
  }


  /**
   * Fetch ListItems By Title.
   * @param spContext 
   * @param listTitle 
   * @param selectFields 
   * @returns 
   */
  public fetchListItemsByTitle = async (
    spContext: any,
    listTitle: string,
    selectFields: string
  ): Promise<any> => {
    if (!listTitle) {
      return Promise.reject("No list specified.");
    }

    const response = await (
      await spContext.spHttpClient.get(
        `${spContext.pageContext.web.absoluteUrl}/_api/web/lists/getByTitle('${listTitle}')/items?$select=` +
        selectFields,
        SPHttpClient.configurations.v1
      )
    ).json();

    return Promise.resolve(response);
  };

  /**
   * Checks for user compliance
   * @param [UpdateTrue]
   * @returns boolean
   */
  public async checkForUserCompliance(UpdateTrue?: boolean): Promise<boolean> {
    try {
        const responseUserProfile = await this.checkUserProfile();
        
        //checking from User profile if user is compliant, if user profile doesn't has hcltech-restricted then calling compliant API to chec for compliance
        if (Constants.IsNullOrUndefinedOrEmpty(responseUserProfile)) {
          return await this.ReadConfigurationFromList().then(
            async (response: any) => {
                var requestPayloadForComplianceAPI = {
                  UpdateTrue: UpdateTrue,
                  logger: this.loggerHelper,
                  apiURL: response.ComplianceAPIURL,
                  APImethod: response.APImethod,
                  OcpApimSubscriptionKey: response.OcpApimSubscriptionKey,
                  OcpApimTrace: response.OcpApimTrace,
                  RequestObject: response.RequestObject,
                  APITimeoutLimit: response.APITimeoutLimit,
                  Scope:response.Scope,
                  context:this._context
                };
                const complianceResponse =
                  await this.spHelper.InvokeComplianceAPI(
                    requestPayloadForComplianceAPI,
                    this._context,
                    this._context.pageContext.user.loginName
                  );
                return Promise.resolve(complianceResponse);
              
            }
          );
        } else if (
          !Constants.IsNullOrUndefinedOrEmpty(responseUserProfile) && responseUserProfile?.split("|")[0] == Constants.GuidForCompliantUser && responseUserProfile?.split("|")[1] == this.getCurrentUTCDate()
        ) {
          return Promise.resolve(true);

        } else {

          return await this.ReadConfigurationFromList().then(
            async (response: any) => {
                var requestPayloadForComplianceAPI = {
                  UpdateTrue: UpdateTrue,
                  logger: this.loggerHelper,
                  apiURL: response.ComplianceAPIURL,
                  APImethod: response.APImethod,
                  OcpApimSubscriptionKey: response.OcpApimSubscriptionKey,
                  OcpApimTrace: response.OcpApimTrace,
                  RequestObject: response.RequestObject,
                  APITimeoutLimit: response.APITimeoutLimit,
                  context:this._context,
                  Scope:response.Scope
                };
                const complianceResponse =
                  await this.spHelper.InvokeComplianceAPI(
                    requestPayloadForComplianceAPI,
                    this._context,
                    this._context.pageContext.user.loginName
                  );
                return Promise.resolve(complianceResponse);
              
            }
          );
        }
      
    } catch (ex) {
      
      this.loggerHelper.trackException(ex, {
        message: "Exception in " + "checkForUserCompliance method Util."
      });
      return Promise.resolve(true);
    }


  }
  /**
   * Gets current utcdate
   * @returns current utcdate
   */
  public getCurrentUTCDate(): string {
    let currentUTCDate: string;
    var today = new Date();
    currentUTCDate =
      today.getUTCFullYear() +
      "-" +
      (today.getUTCMonth() + 1) +
      "-" +
      today.getUTCDate();

    return currentUTCDate;
  }

  /**
 * Gets user profile hcltech-restricted value
 * @returns user profile hcltech-restricted value
 */
  private async checkUserProfile(): Promise<any> {
    this.spHelper = new SPOHelper(this._context, {
      logger: this.loggerHelper
    });
    return await this.spHelper.getUserProfilePropertyValue(
      this._context,
      Constants.UserProfileProperty,
      this._context.pageContext.user.loginName
    );
  }



  /**
   * Format time in AM PM
   * @param date 
   * @returns 
   */
  public static formatAMPM(date: Date): string {
    var hours = date.getUTCHours();
    var minutes = date.getUTCMinutes();
    let strMinutes: string = '';
    var ampm = hours >= 12 ? 'PM' : 'AM';
    hours = hours % 12;
    hours = hours ? hours : 12; // the hour '0' should be '12'
    strMinutes = minutes < 10 ? '0' + minutes.toString() : minutes.toString();
    var strTime = hours + ':' + strMinutes + ' ' + ampm;
    return strTime;
  }

  /**
   * get Double Digit
   * @param digit 
   * @returns 
   */
  public static getDoubleDigit(digit: number): string {
    let strDigit: string = '';
    strDigit = digit < 10 ? '0' + digit.toString() : digit.toString();
    return strDigit;
  }

  /**
 * get Only Date From DateTime
 * @param EventDate 
 */
  public static getOnlyDateFromDateTime(EventDate: string): string {
    const d = new Date(EventDate);
    const temp = d.getUTCFullYear() + "-" + this.getDoubleDigit((d.getUTCMonth() + 1)) + "-" + this.getDoubleDigit(d.getUTCDate());
    return temp;
  }

  /**
   * get Only Time From DateTime
   * @param EventDate 
   * @returns 
   */
  public static getOnlyTimeFromDateTime(EventDate: string): string {
    const d = new Date(EventDate);
    const temp = this.getDoubleDigit(d.getUTCHours()) + ":" + this.getDoubleDigit(d.getUTCMinutes()) + ":" +this.getDoubleDigit(d.getUTCSeconds()) + "Z";
    return temp;
  }
}
