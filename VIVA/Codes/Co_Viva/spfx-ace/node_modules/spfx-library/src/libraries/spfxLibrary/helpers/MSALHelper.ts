import {
  AccountInfo,
  InteractionRequiredAuthError,
  PublicClientApplication
} from "@azure/msal-browser";
import { Constants } from "./Constants";
import { LoggerHelper } from "./LoggerHelper";

/**
 * MSAL Helper.
 */
export class MSALHelper {
  private loggerHelper: LoggerHelper;
  private myMSALObj: PublicClientApplication;
  private userLoginName: string;
  private ssoRequest: any;

  constructor(configuration: any) {
    try {
      this.loggerHelper = configuration.logger;
      this.userLoginName = configuration.loginName;
      const msalConfig = {
        auth: {
          authority: Constants.AutorityUrl.replace(
            Constants.TenantIdPlaceHolder,
            configuration.tenantId
          ),
          clientId: configuration.clientId,
          redirectUri: configuration.redirectUrl,
          system: {
            iframeHashTimeout: 60000 // Set a higher timeout value (e.g., 60 seconds)
          }
        },
        cache: {
          cacheLocation: "localStorage", // set your cache location to local storage
        },
      };

      this.ssoRequest = {
        scopes: configuration.scope,
        loginHint: this.userLoginName,
        authority: Constants.AutorityUrl.replace(
          Constants.TenantIdPlaceHolder,
          configuration.tenantId
        ),
        redirectUri: configuration.redirectUrl
      };
      this.loggerHelper.trackException("Not a exception in MSAL Constructor",{msalpayload : msalConfig});
      this.myMSALObj = new PublicClientApplication(msalConfig);
    } catch (ex) {
      this.loggerHelper.trackException("Exception in MSAL constructor",{ex:ex});
    }
  }

  /**
   * Method to  retrieve Access Token.
   * @param scopes the scopes.
   */
  public retrieveAccessToken = async (scopes?: any): Promise<any> => {
    this.loggerHelper.trackException("Not a exception in MSAL retrieve access token",{scopes : scopes});
    if (scopes && scopes.length > 0) {
      this.ssoRequest.scopes = scopes;
    }

    const accounts = this.myMSALObj.getAllAccounts();
    if (accounts !== null && accounts.length > 0) {
      this.loggerHelper.trackTrace("Account not null and length more than 0");
      this.loggerHelper.trackTrace(accounts);
      return this.handleLoggedInUser(accounts);
    } else {
      this.loggerHelper.trackTrace("accounts null or length 0");
      return this.loginForAccessTokenByMSAL()
        .then((token) => {       
          return Promise.resolve(token);
        })
        .catch((error) => {
         
          this.loggerHelper.trackException(error, {
            message: "Error occured in the retrieving graph token.", error:error
          });
          return Promise.resolve(null);
        });
    }
  };

  /**
   * Method to retrive accesstoken for logged in user.
   * @param currentAccounts the current login account.
   */

  private handleLoggedInUser = async (
    currentAccounts: AccountInfo[]
  ): Promise<any> => {
    let accountObj = null;
    if (currentAccounts === null) {
      this.loggerHelper.trackTrace("No user signed in");
      return "No user signed in";
    } else if (currentAccounts.length > 1) {
      this.loggerHelper.trackTrace("User Login Name " + this.userLoginName);
      // More than one user is authenticated, get current one
      accountObj = this.myMSALObj.getAccountByUsername(this.userLoginName);
      this.loggerHelper.trackTrace("accountObj get");
    } else {
      accountObj = currentAccounts[0];
    }
    this.loggerHelper.trackTrace(accountObj?.username?.toString());
    this.loggerHelper.trackTrace(accountObj);

    if (accountObj !== null) {
      this.loggerHelper.trackTrace("Account obj not null");

      this.ssoRequest.account = accountObj;
      return this.myMSALObj
        .acquireTokenSilent(this.ssoRequest)
        .then((accessToken) => {
          return accessToken.accessToken;
        })
        .catch(async (error) => {
            this.loggerHelper.trackException(error, {
                message: "Error occured in the retrieving token 1.", error:error
              });
          try {
                const token = await this.loginForAccessTokenByMSAL();
                
                return token;
            } catch (error_1) {
                
                this.loggerHelper.trackException(error_1, {
                    message: "Error occured in the retrieving token 2.", error:error_1
                });
                return null;
            }
        });
    }
  };

  /**
   * Method returns access token for login.
   */
  private loginForAccessTokenByMSAL = async (): Promise<string> => {
    this.loggerHelper.trackException("Not a exception in loginForAccessTokenByMSAL",{ssoRequest:this.ssoRequest});
    return this.myMSALObj
      .ssoSilent({scopes:this.ssoRequest.scopes, prompt:"none"})
      .then((response) => {
        return response.accessToken;
      })
      .catch(async (error) => {
        this.loggerHelper.trackException("Exception in loginForAccessTokenByMSAL 1",{ssoRequest:this.ssoRequest,error:error});
        if (error instanceof InteractionRequiredAuthError) {
          try {
                const response = await this.myMSALObj
                    .loginPopup(this.ssoRequest);
                return response.accessToken;
            } catch (error_1) {
              this.loggerHelper.trackException("Exception in loginForAccessTokenByMSAL 2",{ssoRequest:this.ssoRequest,error:error_1});
                return null;
            }
        } else {
          return null;
        }
      });
  };
}
