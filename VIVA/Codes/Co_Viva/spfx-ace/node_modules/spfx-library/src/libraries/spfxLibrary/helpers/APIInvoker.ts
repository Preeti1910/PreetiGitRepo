import { Constants } from "./Constants";
import { LoggerHelper } from "./LoggerHelper";
import { AadHttpClient, IHttpClientOptions } from '@microsoft/sp-http';

/**
 * Class APIInvoker   
 */
export class APIInvoker {

    private loggerHelper: LoggerHelper;
    private promiseTimeout: any;

    constructor(configuration: any) {
        var apiTimeout = 0;
        this.loggerHelper = configuration.logger;
        if (!Constants.IsNullOrUndefinedOrEmpty(configuration.APITimeoutLimit)) {
            apiTimeout = parseInt(configuration.APITimeoutLimit);
        }

        this.promiseTimeout = new Promise((resolve) => (setTimeout(() => resolve(Constants.APITimeoutMessage), apiTimeout)));
    }

    /**
    * Method to retrieve Access Token For external.
    * @param configuration the request payload.
    * @returns string.
    */
    public retrieveAccessTokenForexternal(configuration: any): string | PromiseLike<any> {
        const apiURL = configuration.externalTokenURL;

        return fetch(apiURL, {
            method: "POST"
        }).then((response) => response.json())
            .then((result) => {
                return result;
            })
            .catch((error) => {
                this.loggerHelper.trackException(error, { message: 'Error from retrieveAccessTokenForexternal:', payload: configuration });
                return null;
            });

    }

    /**
    * Method to to send API request.
    * @param requestPayload the request payload.
    * @returns the search results.
    */

    public sendAPIRequest = async (requestPayload: any): Promise<any> => {

        const apiURL = requestPayload.apiURL.trim();
        const requestObj = requestPayload.requestObj;
        const payload = requestObj ? requestObj : '';

        var myHeaders = new Headers();
        myHeaders.append("Content-Type", "application/json");
        this.loggerHelper.trackTrace("Api Invoker Send Api for url " + apiURL, requestPayload);

        if (requestPayload.accessToken) {
            myHeaders.append("Authorization", "Bearer " + requestPayload.accessToken);
        }
        if (requestPayload.OcpApimTrace) {
            myHeaders.append("Ocp-Apim-Trace", requestPayload.OcpApimTrace);
        }
        if (requestPayload.OcpApimSubscriptionKey) {
            myHeaders.append("Ocp-Apim-Subscription-Key", requestPayload.OcpApimSubscriptionKey);
        }
        if (requestPayload.AuthorizationKey) {
            myHeaders.append("Authorization", requestPayload.AuthorizationKey);
        }
        if (requestPayload.AuthorizationBasicKey) {
            myHeaders.append("Authorization", "Basic " + requestPayload.AuthorizationBasicKey);
        }

        if (requestPayload.APImethod.toLowerCase() === "get") {
            return fetch(apiURL, {
                method: "GET",
                headers: myHeaders
            }).then((response) => {
                if (!Constants.IsNullOrUndefinedOrEmpty(response) && (response.status == 200 || response.status == 201)) {
                    return response?.json()
                }
                else {
                    this.loggerHelper.trackException(response, { message: 'Response status is not 200 for apiUrl : ' + apiURL, payload: requestPayload });
                    return null
                }
            })
                .then((result) => {
                    return result;
                })
                .catch((error) => {
                    this.loggerHelper.trackException(error, { message: 'Error sendAPIRequest get in apiUrl : ' + apiURL, payload: requestPayload });
                    return Promise.resolve(null);
                });
        } else if (requestPayload.APImethod.toLowerCase() === "post") {
            return fetch(apiURL, {
                method: "POST",
                headers: myHeaders,
                body: payload
            }).then((response) => { return response.text() })
                .then((data) => {
                    return Promise.resolve(data);
                }).catch(error => {
                    this.loggerHelper.trackException(error, { message: 'sendAPIRequest post error: in apiUrl :' + apiURL, payload: requestPayload });
                    return Promise.resolve(null);
                });
        }
    }

    /**
 * Method to call API.
 * @param requestPayload the request payload.
 * @returns the search results.
 */
    public callAPI = async (requestPayload: any): Promise<any> => {
        const response = await Promise.race([this.promiseTimeout, this.sendAPIRequest_AAdHttpClient(requestPayload)]);

        if (response === Constants.APITimeoutMessage) {
            //log API details to application insight
            this.loggerHelper.trackTrace(Constants.APITimeoutMessage + ', API:' + requestPayload.apiURL);
        }
        else {
        }
        return Promise.resolve(response);
    }



    /**
     * Retrieve service acount access token json of apiinvoker
     * @param configuration
     */
    public retrieveServiceAcountAccessTokenJson = async (configuration: any): Promise<any> => {



        var requestObj = {
            client_id: configuration.clientId,
            client_secret: configuration.clientSecret,
            grant_type: configuration.grantType,
            scope: configuration.scope
        }
        var apiURL = "https://login.microsoftonline.com/" + configuration.tenantId + "/oauth2/v2.0/token";

        var payload = requestObj ? JSON.stringify(requestObj) : '';

        return fetch(apiURL, {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: payload
        }).then((response) => response.json())
            .then((result) => {
                return result;
            })
            .catch((error) => {
                this.loggerHelper.trackException(error, { message: 'Error retrieveServiceAcountAccessTokenJson' });
            });


    }

    /**
 * Method to  retrieve Service Acount Access Token.
 * @param configuration 
 * @returns access token.
 */
    public retrieveServiceAcountAccessToken(configuration: any): string | PromiseLike<any> {
        var myHeaders = new Headers();
        myHeaders.append("Content-Type", "application/x-www-form-urlencoded");

        var formdata = new FormData();

        formdata.append("client_id", configuration.clientId);
        formdata.append("client_secret", configuration.clientSecret);
        //formdata.append("resource", "api://399557e2-0984-4a3a-868c-d9093e395506");
        formdata.append("scope", configuration.scope);
        formdata.append("grant_type", "client_credentials");
        // var url = "https://login.microsoftonline.com/189de737-c93a-4f5a-8b68-6f4ca9941912/oauth2/token";
        var url = "https://login.microsoftonline.com/" + configuration.tenantId + "/oauth2/v2.0/token";

        var requestOptions = {
            method: 'POST',
            headers: myHeaders,
            body: formdata
            // mode: 'no-cors'
            // redirect: 'follow'
        };

        fetch(url, requestOptions)
            .then(response => response.text())
            .then(result => {
                return result;
            }
            ).catch((error) => {
                this.loggerHelper.trackException(error, { message: 'Error for ServiceAcountAccessToken' });
            });
        return null;
    }

    /**
     * Getprofile photo of apiinvoker
     * @param requestPayload
     */
    public getprofilePhoto = async (requestPayload: any): Promise<any> => {

        try {
            const apiURL = requestPayload.apiURL.trim();
            const response = await fetch(apiURL, {
                headers: { Authorization: 'Bearer ' + requestPayload.accessToken },
            });


            const pictureBlob = await response.blob();
            return pictureBlob;
        } catch (error) {
            this.loggerHelper.trackException(error, { message: 'getprofilePhoto error:' });
            return error;
        }

    }

    public sendAPIRequest_AAdHttpClient = async (requestPayload: any): Promise<any> => {

        const apiURL = requestPayload.apiURL.trim();
        const requestObj = requestPayload.requestObj;
        const payload = requestObj ? requestObj : '';
        let response;

        var myHeaders = new Headers();
        myHeaders.append("Content-Type", "application/json");
        this.loggerHelper.trackTrace("Api Invoker Send Api for url " + apiURL, requestPayload);

        if (requestPayload.accessToken) {
            myHeaders.append("Authorization", "Bearer " + requestPayload.accessToken);
        }
        if (requestPayload.OcpApimTrace) {
            myHeaders.append("Ocp-Apim-Trace", requestPayload.OcpApimTrace);
        }
        if (requestPayload.OcpApimSubscriptionKey) {
            myHeaders.append("Ocp-Apim-Subscription-Key", requestPayload.OcpApimSubscriptionKey);
        }
        if (requestPayload.AuthorizationKey) {
            myHeaders.append("Authorization", requestPayload.AuthorizationKey);
        }
        if (requestPayload.AuthorizationBasicKey) {
            myHeaders.append("Authorization", "Basic " + requestPayload.AuthorizationBasicKey);
        }

        if (requestPayload.APImethod.toLowerCase() === "get") {
            try {
                const httpClientOptions: IHttpClientOptions = {
                    headers: myHeaders
                };
                if (!Constants.IsNullOrUndefinedOrEmpty(requestPayload.Scope)) {
                    const aadClient = await requestPayload.context.aadHttpClientFactory.getClient(requestPayload.Scope);
                    response = await aadClient.get(apiURL, AadHttpClient.configurations.v1, httpClientOptions);
                    const json = await response.text();
                    const parsedJson = JSON.parse(json)
                    return Promise.resolve(parsedJson);
                }
                else {
                    return fetch(apiURL, {
                        method: "GET",
                        headers: myHeaders
                    }).then((response) => response.json())
                        .then((result) => {
                            this.loggerHelper.trackTrace('Success sendAPIRequest_AAdHttpClient get:', result);
                            return result;
                        })
                        .catch((error) => {
                            this.loggerHelper.trackException(error, { message: 'Error sendAPIRequest_AAdHttpClient get:' });
                        });
                }
            }
            catch (error) {
                this.loggerHelper.trackException(error, { message: 'sendAPIRequestAAdClient post error: in apiUrl :' + apiURL, "payload": requestPayload });
                return Promise.resolve({error:error});
            }

        } else if (requestPayload.APImethod.toLowerCase() === "post") {
            try {
                const httpClientOptions: IHttpClientOptions = {
                    headers: myHeaders,
                    body: payload
                };
                if (!Constants.IsNullOrUndefinedOrEmpty(requestPayload.Scope)) {
                    const aadClient = await requestPayload.context.aadHttpClientFactory.getClient(requestPayload.Scope);
                    response = await aadClient.post(apiURL, AadHttpClient.configurations.v1, httpClientOptions);
                    const json = await response.text();
                    const parsedJson = JSON.parse(json)
                    return Promise.resolve(parsedJson);
                }
                else {
                    return fetch(apiURL, {
                        method: "POST",
                        headers: myHeaders,
                        body: payload
                    }).then((response) => { return response.json() })
                        .then((data) => {
                            return Promise.resolve(data);
                        }).catch(error => {
                            this.loggerHelper.trackException(error, { message: 'sendAPIRequestAAdClient post error: in apiUrl :' + apiURL, payload: requestPayload });
                            return Promise.resolve({error:error});
                        });
                }
            }
            catch (error) {
                this.loggerHelper.trackException(error, { message: 'sendAPIRequestAAdClient post error: in apiUrl :' + apiURL, "payload": requestPayload });
                return Promise.resolve({error:error});
            }
        }
    }
}